New Requirements - Use can select to read from web or from file based on user input

(Start with Test Shells first)

Step 1 - Move (alg) Logic to .WordCounting
Step 2 - Setup Http 
    --- no binding for WebClient
Step 3 Create WordCountingEngine ties all the pieces together
    --- ties all the SR pieces together
Step 4 Create UI.Repl
Step 5 Note how we can't create a Repl, implementation of IWordCountEngine is internal, can't access.  Temporary give access now.
Step 6 Update Main().  Highlight manual creation of object graph (poor man DI)
Step 7 Run
Step 8 Write initial unit test
 -- Use [TestCase] to extract input arguments from Test Case
 -- Use SkyKick.Bcl.Extensions to read Embedded Resources
 -- Use MockRepository to create a dynamic proxy object 
 that allows us a number of powerful options.  We can stub
 out fake behaviors, inspect method arguments and a lot more.
 This is your entry point for creating this mocked objects.  It's 
 possible to use concrete objects that have virtual methods, but its
 a hell of a lot easier to use interfaces.  Which is one of the 
 reasons why its good practice to create an interface, 
 even if you will only have one implementation.
 -- Use .Stub (as opposed to .Expect) - provide behavior,
    but don't need to validate it's called
 -- Arg.Is() mostly convienance here, but also validates
    input is passed in correctly
 -- Should library has conienance methods for Asserts

 CheckPoint 1
 -- Introduce Ninject (replaces building object graph)
 Step 9 Create Kernel in UI
     - Add Statup class with a Build Kernel method.  
	    This should NOT be static.
     Kernel should only be accessed from an Entry Point
	 (RoleEntryPoint for Cloud Services, Main in Console
	 Web Apps use a plugin that injects kernel into the 
	 Controller Factory, so you never access it directly)
	 - Call BuildKernel in main

Step 10 Run Program - Note Activation Exception.  Can't find
    IWordCountingEngine.  Because we haven't added a binding for it yet.

Step 11 Add Ninject Module for .WordCounting
        Highlight using NonPublicTypes.  There
		should be no reason to leak concrete implementations
		other than to the Test class that's explicitly testing
		these types.
		Remove .UI from InternalsVisibleTo
        Update BuildKernel()
		   Highlight using full namespace

Step 12 Run Program - Note different Activation Exception  (IWebClient)

Step 13 Lets TDD this problem.  
       Create a Test proving Bindings
	   Verify failure

Step 14 Manual Binding
		WebClientWrapper does not match default naming convention,
		add manual binding

CheckPoint 2

Step 15 Run Bindings Test
     Note, we've made progress, but still getting Activation Exception()
	 But we're closer - missing a binding for SkyKick.Bcl.Logging

Step 16 Adding binding for SkyKick.Bcl.Logging
     we'll add the NinjectModule that comes with that library

Step 17 Run Bindings Test - Confirm that test passes.

Step 18 Run UI - Confirm application works

Step 19 Clean up WordCountingEngineTests
     We can use a kernel instead of creating
	 WordCountingEngine manually
	 - Show use of .ReBind() - ninject alreadys has a binding, 
	 we need to replace it.
	 - .ToContant allows us to bind to an existing instance rather
	 than a type that Ninject will control creating.
	 - Highlihgt importance of .BuildKernel creating a new instance
	 every time.  Because we are manipulating bindings we need
	 to make sure we have a fresh instance, otherwise we could be polluting
	 other tests, or other tests could have polluted us by chaning bindings.
	 - Confirm test works

Check Point 3

The core prototype "works", has been converted to use SOLID principles and
we have 86% code coverage of .WordCounting.

But the core algorithm is not very good.  Lets prove it's not as robust as
it could be by adding a failing a test.  This is TDD style, we've found a bug
so first lets verify we can reproduce the bad behavior

   Step 20 Add WordsWithEntersAndNoSpaces
       Be sure to mark as embedded resource

   Step 21 Add new input file to CountsWordsInSampleFilesCorrectly
       Verify test fails

	Step 22  Update Word Counting Algorithm - very simple/naive fix

	Step 23 Re run CountsWordsInSampleFilesCorrectly and verify bug is fixed

Check Point 4

We are missing cross cutting concerns.  Lets add some in and see how they 
can be tested.

Lets add the requirement that if the IWebClient throws a general exception or 
gets a 500, we should retry 3 times with a back off period of 0.5s, 1s and 10s.

   Step 24  Add Polly to .WordCounting

   Step 25 Update WebTextSource 
      - We could add retry to WebClientWrapper, but we want wrappers
	    to be very light weight, they really shouldn't include any 
	    additional logic ontop of the api code they wrap.
	  - Note how WebTextSourceOptions is injected.  This means
	    WebTextSource is not responsible for knowing how to get its
		own settings, it must be injected.  This also gives us great flexiblity
		for testing.
	  - Its ok for WebTextSourceOptions to include a default
	  - This pattern aligns very nicely with SkyKick.Bcl.Configuration
	    which provides a DI supported subsytem for configuration
	  - Note: on the ExecuteAsync lambda, the _ for the lambda parameter.
	    This is short hand indicating that the variable (cancellation token)
		wont be used.

	Step 26 Add WebTextSourceTests
	  - Normally it would be very hard to test a retry policy based 
	    on an exception thrown by a 3rd party/framework utility, but
		because we have a wrapper and WebTextSourceOptions, it's quite easy
	  - Use [TestCaseSouce] to point to a method that generates test input,
	    allowing us to run code to generate Test Cases, wouldn't be possible
		with just [TestCase].  This allows our test code to test a single hypothesis
		(specific eception throws error) while still maximizing code reuse
	  - Use .Expect() to have the ability to Verify that method was called
	    with given method parameters a set number of times.
	  - Use .Thorw() to easily have a mock throw an exception
	  - We create a WebTextSourceOptions with an array of 0 second retry times
	    to Verify() that the retry policy is retrying Web Requests
	  - Use VerifyAllExpectations() to verify GetHtmlAsync was called the correct
	    number of times

	Step 27 Run Unit Tests
	   - Note two tests pass, but the test where we did NOT expect the
	     retry behavior to be triggered failed.
		 --- We found a bug in the retry logic - it retries on 
		     a non-transient exception.  That would have been very very
		     hard to identify in a running system!
       - The Exception that is logged is quiet daunting.  We caught
	     an exception, but it's not the exception we thought it would be, 
		 so the ShouldEqaul(webClientException) threw a new exception. 
		 The "Actual" exception is what was thrown by the WebTextSource:
		 A NullReferenceException.
		    --- This is a very important exception to understand when
			working with Mocks, especially when dealing with Async code.
			--- Key to understanding is knowing how a Mock behaves by default,
			    which is it will return default() for any method that has 
				not been stubbed with either Stub() or Expect().  When we
				an Async method is called on a Mock with no Stub, Rhino
				will return null, and the code will end up trying to `await null`
				which leades to the NullReferenceException.

Check Point 5

	Step 28 Strict Mock
		- Improve InvokesRetryPolicyOnErrors by changing 
		  GenerateMock() to GenerateStrictMock()
		- Rerun the failing test
		- We now get a better Exception in the Actual output a
		  ExpectationViolationException.  Using Strict mocks will
		  have Rhino throw a very specific Exception if the code 
		  under test tries to invoke a method that hasn't been stubbed.
		  This is quite useful for helping to diagnose failing tests
		  that use mocks, and is something I'm working on using more myself.

	Step 29 Fix WebTextSource
	    - Update .Or<Exception> to exclude handling a generic exception
		  if it is a WebException: .Or<Exception>(ex => !(ex is WebException)) 
		
	Step 30 Run All Tests
		- Verify that you just diagnosed and fixed a retry policy bug
		  completly in unit tests, before your code ever made it to prod!
		
Check Point 6

 Step X - Singleton - add a delay and initialization in WebClient to simulate a 
         auth handshake.  Run Program note how delay occurs every time.
		  Add Singleton() notice how delay only happens once.
 